**JavaScript и его библиотеки, css, html и прочее**

[JavaScript](#JavaScript)
[GSAP](#GSAP)
[CSS](#CSS)

# JavaScript

  ## Оглавление JavaScript


  1. [Вводные вопросы](#Вводные-вопросы)
  1.1[VS Code](#VS-Code)
  2. [Переменные](#Переменные)
  3. [Типы данных](#Типы-данных)
  4. [Простое общение с пользователем](#Простое-общение-с-пользователем)
  4.1 [Интерполяция](#Интерполяция)
  5. [Операторы в JS](#Операторы-вJS)
  6. [Строгий режим](#Строгий-режим)
  7. [Система контроля версий Git](#Система-контроля-версий-Git)
  7.1[Сетевые протоколы](#Сетевые-протоколы)
  8. [Условия](#Условия)
  9. [Циклы](#Циклы)
  10. [Функции](#Функции)
  11. [Методы и свойства у строк и чисел](#Методы-и-свойства)
  12. [Callback функции и области применения](#Callback-функции)
  13. [Объекты](#Объекты)
  14. [Массивы](#Массивы)
  15.1 [Разница между массивами и объектами](#Разница-между-массивами-и-объектами)
  15. [Объектно ориентированное программирование](#Объектно-ориентированное-программирование)
  16. [Получение элементов со страницы](#Получение-элементов-со-страницы])
  16. [Действия с элементами на странице](#Действия-с-элементами-на-странице)
  17. [События и их обработчики](#События-и-их-обработчики)
  18. [Скрипты и время их выполнения setTimeout](#Скрипты-и-время-их-выполнения-setTimeout)
  19. [Параметры документа, окна и работа с ними](#Параметры-документа,-окна-и-работа-с-ними)
  20. [Работа в console](#Работа-в-console)

  ## Вводные вопросы

  1. Java Script это высокоуровневый язык, все, что мы пишем будет воспринято браузером как есть
  2. Подключить JS можно либо в самом html документе либо в отдельном документе
  3. Коментарий может быть однострочным и многострочным // или /\* \*/
  4. Строгий режим 'use strict';

  ## VS Code

  C:\Users\Toxa\AppData\Local\Programs\Microsoft VS Code (папка где храниться)

  ## Переменные

  1. Переменные это хранилище данных в JS, они записываются так:

  var leftBorderWidth = 10; (var это старый формат)
  let second = 2; (let новый формат ES6 эта переменная изменяется)
  const pi = 3.14

  2. Переменные не должны начинаться с чисел, а также не должны быть зарезервирываными словами например null
  3. Разница между let и var:

  console.log(leftBorderWidth)
  a) var leftBorderWidth = 10; эта переменная которая видна по всему коду, в отличии от let если обьявить переменную и попытаться вывести ее в console раньше чем она обьявленна, то получим undefined, тоесть переменная создана, но она не имеет ни какого значения.

  console.log(second)
  б) let second = 2; если проделать ту же манипуляцию с let, то получим в console second is not defined, тоесть переменную код не может найти, и выдаст нам ошибку.

        Кроме этого let видна только в блоке ограничеными фигурными скобками-

        {
          let second = 2;
        }
        console.log(second)
        в console выведет second is not defined

  в) const схож по своему поведению с let единственное значение const нельзя обьявить и не присвоить ей значение и нельзя менять значение

  4. Стили переменных
  <!-- snake_case --> используется для названия папок и файлов
  <!-- UPPER_SNAKE_CASE --> используется для названия переменных в виде const
  <!-- Kebab-case --> используется для названия папок и файлов
  <!-- PascalCase --> используется для названия class 
  <!-- _apiBase || _apiKey --> ключи или ссылки

  ## Типы данных

  Существует всего 8 типов данных

  1. var number = 5; // число
  2. var string = "Hello!"; // строка
  3. var sym = Symbol(); // символ
  4. var boolean = true || false или логический
  5. null; чегото нет 
  6. undefined; что то существует но нет значения
  7. obj = {} объект
  8. BigInt

  9. числа могут быть как целые так и дробные, также специальные числавые значения ifinity если делить на ноль и not is Number или NuN если число умножим или разделим на строку, то получим такой результат
    console.log(4/0) - ifinity (бесконечность)
    console.log('sting'*9) - NaN (не число)

  10. строка всегда пишеться в кавычках 'Иья' или "Отчество"
      или `Фамилия` это обратные кавычки

  11. По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.
      «Символ» представляет собой уникальный идентификатор.
      Создаются новые символы с помощью функции Symbol():

  let id = Symbol();

  4. var boolean = true || false или

  5. если вывести в console чтото чего нет, то будет ошибка это и есть null console.log(something) выдаст ошибку такой переменной нет

  6. undefined это когда обьект существует, но значения нет

  let something;
  console.log(something)

  7. Тип object (объект) – особенный.

  Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.

  let persone = {
  name: "John",
  age: 25,
  isMarried: false
  }

  console.log(persone.name)-если вложенности нет
  console.log(persone.["name"])-если вложенность большая

  массив let arr =['plum.png','orange.jpg','apple.bmp'];
  console.log(arr[0]) выведет prum.png так как нумерация в js начинается с нуля

  8. Для большинства случаев достаточно безопасного диапазона чисел от -(2 в 53-1) до (2 в 53-1). Но иногда нам нужен диапазон действительно гигантских целых чисел без каких-либо ограничений или пропущенных значений внутри него. Например, в криптографии или при использовании метки времени («timestamp») с микросекундами.

  Тип BigInt был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.

  Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:

  // символ "n" в конце означает, что это BigInt
  const bigInt = 1234567890123456789012345678901234567890n;

  Типы данных делятся на

  простые типы это:
  Чиса 1,2,3
  Строки 'string','name'
  Логический тип (boolean)
  true/false
  null
  undefined
  Symbol

  специальные обьекты:
  Массивы []
  Функции function
  Объект Даты
  Регулярные выражения
  Ошибки

  ## Простое общение с пользователем

  Для того чтобы вывести этот код в редакторе его нужно выделить и нажать на правую клавишу, потом нажать на кнопку Run Code
  **let arr =['plum.png','orange.jpg','apple.bmp'];**
  console.log(arr[0])

  **alert('Hello World')** - выведет модальное окно с надписью
  confirm('Are you here') - появиться окно с вопросом и будут 2 кнопки ок и отмена если положить confirm в переменную и вывести в console то мы получим либо true либо false

  **let answer = confirm('Are you here ?')**
  console.log(answer);

  **let answerNext = prompt('Есть ли вам 18?', 'Да')** чтобы все корректно работало в ie нужно оставлять пробел где стоит "Да" и если нет записи то оставлять пробел.
  console.log(answerNext); **Все данные которые мы получаем через prompt будут строки**

  !**чтобы проверить какой тип данных используем typeof**
  console.log(typeof(answer))
  <!-- вся информация полученная от пльзователя будет строкой, чтобы получить число нужно привести наши данные к числовому значению +prompt -->

  document.write('опопорпрп') // команда которая заменит все на странице

  если вывести
  let arr =['plum.png','orange.jpg','apple.bmp'];
  console.log(typeof(arr)) - получиь object

  если выведем console.log(typeof(null)) - получиь object это баг в js

  ## Интерполяция

  Это когда внутри строки мы можем вставить js код 

  <!-- Для того чтобы подставить динамическое значение раньше и сплоьзовали прием конкотенации, пример ниже -->
  const category = 'toys'; 

  console.log('https://someurl.com/' + category + '/' + '4')

  <!-- Теперь используют новый подход ${} -->

  console.log(`https://someurl.com/ ${category}`)

  ## Операторы в JS

  Есть такие операторы в js как
  "\*" - умножение
  "/" - деление
  "-" - вычитание
  "+" - сложение
  "++" - инкремент
  "--" - дикремент
  ">" - оператор больше
  ">=" - оператор больше или равно
  "<" - оператор меньше
  "<=" - оператор меньше или равно
  "%" - этот оператор возвращает остаток от деления двух чисел
  "=" - оператор присваивания
  "==" - не строгое равно(не проверяет тип данных)
  "===" - строгое равно(проверяет тип данных)
  "&&" оператор и (выполниться елси все условия будут верны)
  "||" оператор или (выполниться елси хоть одно из условий будет верно)
  "!" - оператор отрицания если был true то изменится на false

  у "+" есть некоторые особенности **конкотенация строк**
  тоесть если console.log('Max' + ' ' + 'Ivanov') то получим **Max Ivanov** мы здесь склеили имя пробел и отчество

  let answer = **+prompt**('Есть ли вам 18?', 'Да')
  console.log(typeof(answer)) - мы получим number вне зависимости от того какие данны будут введены так как мы поставили перед "+" перед prompt

  если сложить число и строку то мы получим строку
  let age = 18
  let ageString = '18'
  console.log(age + ageString) - получим **1818**
  если мы хотим получить число то console.log(age + +ageString) - получим **36** это называется унарный плюс

  **Инкременты и дикременты**

  let incr = 10,
  decr = 10; - сокращенная запись без многих let, после последней записи обязательно ставить ';'

  incr++
  decr--

  console.log(incr) **11**
  console.log(decr) **9**

  **префиксная форма**
  console.log(++incr) **11**
  console.log(--decr) **9**

  **постфиксная форма**
  console.log(incr++) **10**
  console.log(decr--) **10**
  команда вернет старое значение и только после этого произведет действие

  **%**
  console.log(5%2) **1**

  **равенство**
  console.log("2" == 2) **true**
  console.log("2" === 2) **false**

  **операторы сравнения**

  let isCheked = true,
  isClose = false,
  console.log(isCheked || isClose) - false
  console.log(isCheked && isClose) - true

  **операторы отрицания !**

  let isCheked = true,
  isClose = false,
  console.log(isCheked || **!isClose**) - true











  ## Строгий режим

  **'use strict'** это стандарт ES6, если мы его прописываем то ошибки старой версии будут исправленны например если не явно объявить переменную
  a=5;
  console.log(a);
  выеведет ошибку в ie9 и ниже 'use strict' работает не корректно

  ## Система контроля версий Git
    <!-- Сайт с гит GitHowTo можно посмотреть информацию -->
    Система контроля версий Git - служит для сохранения своих изменений, возвращению к более ранним изменениям, а также для работы в команде передавая свой код на удаленный репозиторий

    1) для начала работы с Git нужно его скачать и установить с официального сайта https://git-scm.com/downloads
    2) далее установим свой git в наш проект с помощью команды **git init**
    3) далее создаем папку README с описанием нашего проекта с помощью команды: **echo >> README.md** в которой будут записаны все ограничения для git репозитория
    4) установим имя пользователя, его можно установить как глобально так локально глобально устанавливается командой **git config --global user.name "Anton"** локально **git config --local user.name "Anton"** 
    5) устанавливаем свою почту так же как и имя можно локально и глобально **git config --local user.email suppertoha.yandex.ru** 

  Команды
  **git add .** - git будет следить за нашими файлами
  **git commit -m"здесь пишем сообщение о комите"**
  **git status** проверить состояние коммита
  **git log** посмотреть все комиты
  **git log --help** вывод докуметации
  **clear** удалить все с console

  - Подробные команды по гиту
      **git init** : Создает новый локальный репозиторий **Git** в текущей директории.
      **git clone <url>**  : Клонирует существующий удаленный репозиторий на локальную машину.
      **git add .**  <файлы>: Добавляет изменения файлов в индекс для последующего коммита.
      **git commit -m**  "сообщение коммита": Фиксирует изменения в локальном репозитории с указанным сообщением коммита.
      **git push** : Отправляет локальные коммиты в удаленный репозиторий.
      **git pull** : Получает и объединяет изменения из удаленного репозитория в текущую ветку.
      **git branch** : Показывает список веток в локальном репозитории.
      **git checkout <ветка>** : Переключается на указанную ветку.
      **git merge <ветка>** : Объединяет указанную ветку с текущей веткой.
      **git status** : Показывает текущее состояние репозитория, включая измененные файлы и ветку.
      **git log** : Показывает историю коммитов в репозитории.
      **git remote add origin <url>** : Связывает локальный репозиторий с удаленным репозиторием.
      **git remote -v** : Показывает список связанных удаленных репозиториев.
      **git fetch** : Извлекает все изменения из удаленного репозитория, но не объединяет их с текущей веткой. Эта команда полезна, когда вы хотите получить обновления из удаленного репозитория, чтобы ознакомиться с ними перед объединением с вашей локальной веткой. После выполнения **git fetch**  вы можете выполнить команду **git merge**  или **git rebase** , чтобы объединить изменения с вашей веткой.
      **git branch <новая ветка>** : Создает новую ветку с указанным именем на основе текущего состояния репозитория. Новая ветка будет содержать все коммиты из текущей ветки, и вы можете свободно вносить изменения в нее без влияния на другие ветки.
      **git checkout -b <новая ветка>** : Создает новую ветку с указанным именем и переключается на нее. Эта команда комбинирует действия **git branch**  и **git checkout**  в одну команду.
      **git remote show origin** : Показывает информацию о удаленном репозитории с именем "origin". Вы можете увидеть URL удаленного репозитория, список веток и другую полезную информацию.
      **git diff** : Показывает различия между рабочим каталогом и индексом (подготовленные изменения) или между индексом и последним коммитом.
      **git reset <файлы>** : Отменяет индексацию (подготовку к коммиту) указанных файлов. Изменения в файлах останутся нетронутыми.
      **git revert <коммит>** : Создает новый коммит, который отменяет изменения, внесенные указанным коммитом. История коммитов остается неизменной, но состояние файлов восстанавливается к состоянию, предшествующему указанному коммиту.

  ## Сетевые протоколы

  Сетевые протоколы - это набор правил и процедур, которые определяют, как устройства в компьютерной сети обмениваются данными. Они обеспечивают стандартизацию и согласованность взаимодействия между различными устройствами и программами в сети.

  Сетевые протоколы определяют форматы данных, способы их передачи, адресацию, маршрутизацию, управление ошибками и другие аспекты коммуникации в сети. Они обеспечивают эффективную и надежную передачу данных от отправителя к получателю.

  Некоторые из самых известных сетевых протоколов включают в себя:

  Протоколы Интернета (TCP/IP): Это семейство протоколов, которые лежат в основе работы Интернета. Они включают протокол передачи данных (TCP), протокол Интернета (IP), протокол управления передачей (TCP), протокол доменных имен (DNS) и другие.

  Ethernet: Этот протокол определяет метод передачи данных в локальных сетях (LAN) с использованием кабельной инфраструктуры. Он определяет форматы кадров, методы доступа к среде передачи данных и другие аспекты сетевой коммуникации.

  Wi-Fi: Это семейство беспроводных протоколов, которые позволяют устройствам подключаться к сети без использования проводного соединения. Wi-Fi протоколы определяют способы передачи данных по радиоканалу и обеспечивают безопасность соединения.

  ## Условия

  if(2*4 == 8){
    console.log('Верно!')
  } else{
    console.log('Неверно')
  } - в данном случае мы получим первый результат, так как условие верно

  **условие с множественной вложеностью**

  let num = 50;

  if (num < 49){
    console.log('Неверно!')
  } else if (num > 100) {
    console.log('Много!')
  } else {
    console.log('Верно')
  };

  **Тернарные операторы**

  let num = 50;

  (num == 50) ? console.log('Верно!') : console.log('Неверно');

  **switch**

  let num = 50;

  switch (num){
    case num < 49:
        console.log('Неверно!')
        break;
    case num > 100:
        console.log('Много!')
        break;
    case num > 80:
      console.log('Все еще много!')
      break;
    case 50:
      console.log('Верно!')
      break;
    default:
      console.log('Что-то пошло не так!')
      break;
  } 
  **основные моменты**
  1) всегда ставим break (выход из условия)
  2) то значение которое верно записываем так case 50:

  ## Циклы
  **1-й способ создания цикла**

    let num = 50;

    while (num < 55) {
      console.log(num)
      num++
    } в console мы получим 50 51 52 53 54 здесь в круглых скобках написано условие что 50 меньше 55 далее мы прибавляем по единице к 50 и когда выполняется цикл на 54 цикл заканчивается.

  **2-й способ создания цикла do while сначала сделает что-то после выполнит цикл**

  let num = 50;

    do {
      console.log(num)
      num++
    } 
    while (num < 55)
  в console мы получим 50 51 52 53 54 только перед этим выполним действие

  **3-й способ создания цикла for**

  for(let i = 1; i < 8; i++) {
    console.log(i)
  } - выведет 1 2 3 4 5 6 7, здесь в условии мы объявляем что пока 1 меньше 8 условие будет выполняться и когда условие приблизиться к 8 оно закончиться

  **чтобы выйти из условия досрочно**
  for(let i = 1; i < 8; i++) {
    if (i == 6){
      **break**
    }
    console.log(i)
  } - выведет 1 2 3 4 5 и выйдет из условия

  **чтобы пропустить этот шаг**
  for(let i = 1; i < 8; i++) {
    if (i == 6){
      **continue**
    }
    console.log(i)
  } - выведет 1 2 3 4 5 7 пропустит 6 можно также сделать условие и пропускать все четные или нечетные значения

  ## Функции

  **Правила для функции**
  1) Имя функции это глагол show, далее что делает эта функция

  2) Функция содержит аргументы в круглых скобках (text) их может быть очень много

  **пример функции**
  showFirstMessage("Hello World!")
  в alert выведеться "Hello World!"

  **это локальная переменная**

  function showFirstMessage(text) {
    alert(text)
    **let num = 20 это локальная переменная**
  }

  console.log(num)
  
  если переменная объявленна внутри функции то она будет не видна с наружи и мы получим ошибку

  **глобальная переменаая**

  **let num = 20 глобальная переменаая ее можно изменять в различных функциях**

  function showFirstMessage(text) {
    alert(text)
    **num = 10**
  }

  console.log(num) выведет 10
  
  **замыкание**

  **let num = 20**

  function showFirstMessage(text) {
    console.log(num) - **выведет 20 если не найдет переменную на этом уровне то пойдет выше до самого верха**
  }

  замыкание это функция вместе со всеми внешними переменными ей доступными

  **return**
  function calc(a,b) {
    return (a + b)
  }

  console.log(calc(3,4)); выведет "7"
  console.log(calc(8,4)); выведет "12"

  **возвращаем переменную из функции**

  function retVar() {
    let num = 50;
    return num;
  }

  let anotherNum = retVar();
  console.log(anotherNum); мы получим "50"

  **function declaretion**

  console.log(calc(3,4)); такую функцию можно вызвать до ее объявления

  function calc(a,b) {
    return (a + b)
  }

  **function exprechion**

  let calc = function calc(a,b) {
    return (a + b)
  }

  это функция котороя помещается в переменную и сработает только после объявления этой функции то есть если ее вызвать раньше объявления она не сработает и выведет ошибку.

  **новый стандат стрелочная функция**

  let calc = (a,b) => a+b или так let calc = (a,b) => (a+b)
  console.log(calc(4,5)); выведет 9

  такая функция не имеет своего контекста вызова

  ## Методы и свойства у строк и чисел

  Методы это вспомогательные функции а свойства это вспомогательные значения

  **свойство length**
  let str = "test"
  console.log(str.length);
  результат будет 4; **свойства пишуться без круглых скобок в конце**

  **методы**
  console.log(str.toUpperCase()); - вернет TEST
  console.log(str.toLowerCase()); - вернет test

  **методы чисел**
  let twelve = '12.2';

  console.log(Math.round(twelve)) округлит до ближайшего целого числа и получим 12

  **методы paseInt и parseFloat**
  let twelve = "12.2px"
  console.log(paseInt(twelve)); - вернет 12 округлит до целого числа
  console.log(parseFloat(twelve)); - вернет 12.2 округлит до числа без px

  ### Бургер меню

  Вы можете очень быстро добавить рабочий бургер к себе на страницу, для этого нужно:

  1. В html вызвать сниппет `g-burger`
  2. На ваше потенциальное меню в html добавить атрибут `data-menu`
  3. В scss вызвать миксин `burger`

  ```
  .burger { @include burger }
  ```

  4. Зайти в файл js/\_functions.js и раскомментировать строку с подключением js-файла бургера
  5. Настроить стили показа меню под себя с помощью класса `menu--active`

  ### Модальное окно

  Вы можете очень быстро добавить рабочее модальное окно к себе на страницу, для этого нужно:

  1. В html вызвать сниппет `g-graph-btn`. Он создаст кнопку для модального окна, ваша задача лишь заполнить атрибут `data-graph-path`
  2. Далее вызвать сниппет `g-graph-modal`. Он создаст базовую разметку окна. Ваша задача - сделать окно по макету, заполнить контент и обязательно обозначить атрибут `data-graph-target` с тем же значением, что и у `data-graph-path`
  3. Зайти в файл vendor.scss и раскомментировать строку с подключением файла graph-modal.min.css
  4. Зайти в файл js/\_functions.js и раскомментировать строку с импортом и подключением библиотеки `GraphModal`

  ### Управление скроллом

  Вы можете отключать\включать скролл на странице (работает даже на iPhone). Для этого нужно:

  1. Зайти в файл js/\_functions.js и раскомментировать строку с импортом функций `disableScroll`, `enableScroll`.
    **Важно!**. Если на странице присутствуют блоки с фиксированным позиционированием (например, шапка), добавьте ей класс `fixed-block`, чтобы этот блок не прыгал при отключении скролла.

  Необязательно использовать функции именно в файле **functions**, делайте как удобно вам.

  ### Табы

  Вы можете очень быстро добавить рабочие табы к себе на страницу, для этого нужно:

  1. В html вызвать сниппет `g-tabs`. Он создаст разметку для табов, ваша задача лишь заполнить атрибут `data-tabs`
  2. Для класса `.tabs` вызвать миксин `tabs` в scss (или же использовать подключение скрипта библиотеки из npm в файле vendor.scss)
  3. Зайти в файл js/\_functions.js и раскомментировать строку с импортом и подключением библиотеки `GraphTabs`

  ### Валидация и отправка данных на почту

  Вы можете быстро настроить валидацию и отправку данных на почту (пока работает в тестовом режиме). Как это использовать:

  1. Создать форму, указав у нее уникальный класс. Также указать уникальные классы для полей ввода.
  2. Создать массив, в котором будут переданы правила плагина <a href="https://github.com/horprogs/Just-validate" target="_blank">just-validate</a>, например:

  ```
  const rules1 = [
    {
      ruleSelector: '.input-name',
      rules: [
        {
          rule: 'minLength',
          value: 3
        },
        {
          rule: 'required',
          value: true,
          errorMessage: 'Заполните имя!'
        }
      ]
    },
    {
      ruleSelector: '.input-tel',
      tel: true,
      telError: 'Введите корректный телефон',
      rules: [
        {
          rule: 'required',
          value: true,
          errorMessage: 'Заполните телефон!'
        }
      ]
    },
  ];
  ```

  **ВАЖНО**. Если в вашей форме есть поле с телефоном, обязательно пропишите в массиве с правилами новые поля: `tel: true, telError: 'Ошибка при вводе телефона'`. 3. Подключить функцию `validateForms`, она находится в _functions.js_, передав туда три параметра:
  3.1. Строку с классом формы
  3.2. Массив правил
  3.3. Если нужно, можно создать свою функцию, которая выполнится после отправки, тогда ее тоже нужно будет передать как аргумент функции `validateForms`.

  Пример кода:

  ```
  import { validateForms } from './functions/validate-forms';
  const rules1 = [
    {
      ruleSelector: '.input-name',
      rules: [
        {
          rule: 'minLength',
          value: 3
        },
        {
          rule: 'required',
          value: true,
          errorMessage: 'Заполните имя!'
        }
      ]
    },
    {
      ruleSelector: '.input-tel',
      tel: true,
      telError: 'Введите корректный телефон',
      rules: [
        {
          rule: 'required',
          value: true,
          errorMessage: 'Заполните телефон!'
        }
      ]
    },
  ];

  const afterForm = () => {
    console.log('Произошла отправка, тут можно писать любые действия');
  };

  validateForms('.form-1', rules1, afterForm);
  ```

  ### Throttle-функция

  Чтобы сгладить управление частоиспользуемыми событиями, вы можете использовать готовую функцию **throttle**. Для этого нужно:

  1. В нужном месте импортировать функцию **throttle()**
  2. Написать нужную вам функцию, например, **func()**
  3. Создать переменную, в которую поместить вызов вашей фукнции внутри throttle, например: `let f = throttle(func)`
  4. Использовать эту переменную как функцию в вызове, например: `window.addEventListener('resize', f)`

  ### Фикс фулскрин блоков

  Нередко блоки с высотой 100vh вызывают проблемы в мобильных браузерах. Решить это поможет готовый модуль fix-fullheight:

  1. Раскомментируйте строку с импортом файла **fix-fullheight.js**
  2. Назначьте на нужный вам блок высоту не 100vh, а `var(--vh)`

  Для этой функции используется ранее упомянутый throttle. Вы можете убрать его, либо изменить время внутри файла **fix-fullheight.js**.

  ### Получение высоты шапки

  Иногда требуется получить точную высоту шапки, если она сделана абсолютным или фиксированным позиционированием, и для этого есть функция `getHeaderHeght`. Как ее использовать:

  1. Раскомментируйте строку с импортом файла **header-height.js**
  2. Используйте css-переменную `--header-height` в нужном вам месте

  Необязательно использовать функции именно в файле **functions**, делайте как удобно вам.

  ### Кастомный скролл

  Для реализации кастомного скролла в сборку установлен плагин **simplebar.js**. Как его использовать:

  1. Раскомментируйте строку с импортом плагина **simplebar**
  2. Добавьте нужному блоку максимальную высоту и атрибут `data-simplebar`

  ### Функции определения вьюпорта

  Вы можете запускать скрипты на определенной ширине (пока что поддержка ресайза не реализована) с помощью готовых функций `isMobile()`, `isTablet()`, `isDesktop()`. Для этого нужно лишь подключить нужную из них из файла, а затем использовать внутри условия `if`.

  ### Тултипы

  Вы можете быстро создать рабочий, доступный тултип, который к тому же будет сам рассчитывать отступы с помощью js. Как это использовать:

  1. В html вызвать сниппет `g-tooltip`. Он создаст кнопку для модального окна, ваша задача лишь заполнить атрибуты `aria-describedby` и `id`.
  2. Далее нужно подключить тултипы (код в файле _functions.js_), и вместо el передать id или class кнопки тултипа, а вместо tooltip передать id или class самого тултипа.
  3. После этого можете стилизовать тултип как вам угодно.

  ### Слайдер

  Вы можете быстро создать рабочий swiper-слайдер. Как это использовать:

  1. В html вызвать сниппет `g-swiper`. Он создаст базовую структуру свайпер-слайдера, вам нужно добавить свой класс для свайпер-контейнера.
  2. Раскомментировать строку с подключением стилей в файле _vendor.scss_
  3. Подключить сам свайпер (код в файле _functions.js_) и использовать его, следуя документации.

  ### Анимации по скроллу

  Вы можете быстро набросать анимаций по скроллу с помощью плагина. Как это использовать:

  1. Подключить код библиотеки AOS.js (код в файле _functions.js_) и инициализировать его.
  2. С помощью атрибутов из документации плагина вызывать те или иные анимации, или написать свою.

  ### Параллакс по скроллу

  Вы можете быстро набросать параллакс элементов по скроллу с помощью плагина. Как это использовать:

  1. Подключить код библиотеки rellax.js (код в файле _functions.js_) и инициализировать его, передав класс элемента (элементов).
  2. Задать этот класс нужным элементам, а также использовать атрибуты из документации для кастомизации анимаций.

  ### Плавный скролл к якорям

  Вы можете сделать плавный скролл к якорям, который работает даже в Safari, с помощью плагина. Как это использовать:

  1. Подключить код библиотеки smooth-scroll.js (код в файле _functions.js_) и инициализировать его, передав селектор всех якорных ссылок.
  2. Раздать всем якорным ссылкам атрибут `data-scroll`.

  ### Свайпы на мобильных устройствах

  Вы можете реализовывать различные взаимодействия со страницей через свайпы на мобильных устройствах с помощью плагина. Как это использовать:

  1. Подключить код библиотеки swiped-events.js (код в файле _functions.js_).
  2. Использовать различные события из библиотеки плагина.

  ### Миксин для Flex-layout (тестовая версия)

  В последней версии сборки я добавил миксин flex-layout (можно найти в папке mixins), в котором реализована типичная сетка для карточек. Вы можете выбирать нужные вам настройки, чтобы сделать сетку быстро и без проблем. Например:

  ```

  <div class="cards">
    <div class="cards__item">Текст</div>
    <div class="cards__item">Текст</div>
    <div class="cards__item">Текст</div>
    <div class="cards__item">Текст</div>
    <div class="cards__item">Текст</div>
    <div class="cards__item">Текст</div>
  </div>

  $options: (
    parentClass: "cards",
    itemsClass: "cards__item",
    desktopGap: 30px,
    desktopElems: 3,
    tablet: "1024px",
    tabletElems: 2,
    tabletGap:  30px,
    mobile: "600px",
    mobileElems: 1,
    mobileGap: 20px
  );

  @include flex-layout($options);

  ```

  В опциях можно выбрать класс-родитель (или же флекс-контейнер, класс для потомков, какой у них будет отступ, на каких разрешениях будет меняться кол-во элементов).
  Пока что миксин в тестовом виде, буду смотреть как он себя покажет. Предлагайте свои варианты, как можно это улучшить, сделать гибче и т.д.

  ## Callback функции и области применения

  **пример 1**
  function first(){
    <!-- что-то делает -->
    setTimeout(function(){
      console.log(1);
    }, 500);
  }

  function second() {
    console.log(2);
  }

  first()
  second() 

  **описание** у нас есть 2 функции первая использует задержку в выполнении кода в 500 милисекунд и она выведеться за второй функцией, но нам нужно чтобы эти функции выводились последовательно. Для этого и служит callback функции

  **пример 2**

  function learnJS(lang, callback){
    console.log("Я учу " + lang)
    callback();
  }

  learnJS("JavaScript", function(){
    console.log('Я прошел 3й урок!')
  })

  **результат**
  Я учу JavaScript
  Я прошел 3й урок! 

  **пример 3**

  function learnJS(lang, callback){
    console.log("Я учу " + lang)
    callback();
  }

  function done() {
    console.log('Я прошел 3й урок!')
  }

  learnJS("JavaScript", done)

  **результат**
  Я учу JavaScript
  Я прошел 3й урок!

  ## Объекты

  let obj = now Object() - один из способов создания объектов(редко используется)

  **Создание объекта и получение из него данных**
  let options = {
    width: 1024,
    height: 1024,
    name: 'test',
    nestedObject = {
      nestedKey: "nestedValue",
    };
  };

  console.log(options.name)

  **Добавление в объект данных**

  let numberOfFilms = prompt('Сколько фильмов вы уже посмотрели?', '')
  let logan  = prompt('На сколько оцениваете фильм?', '')

  let personalMovieDB = {
    count: numberOfFilms,
    movies: {
      
    },
    actors: {
      
    },
    privat: false
  }

  personalMovieDB.movies.logan = logan
  personalMovieDB.movies[logan] = logan

  console.log(personalMovieDB) 

  **Добавим в объект еще данные включая еще один объект**
  options.bool = false;
  options.colors = {
    border: 'black',
    bg: 'red'
  }

  console.log(options); - выведет нам наши данные

  **Удаление из объекта**

  delete options.bool

  **Прохождение циклом по объекту**
  for(let key in options){
    console.log('Свойство ' + key + ' имеет значение ' + options[key]); - где key это ключь
  }

  **--второй способ--**
  console.log(Object.keys(options).length); - где keys это ключи

  ## Массивы

  let arr = [1, 2, 3, 4, 5] - массив и данные массива

  app.pop(); - удаление последнего элемента из массива
  arr.push('5') - добавление в конец массива

  arr.shift() - удаление первого элемента из массива
  arr.unshift() - добавление первого элемента из массива

  **перебор массива**
  let arr = [1, 2, 3, 4, 5]
  for(let i = 0; i < arr.length; i++){
    console.log(arr[i])
  }

  **Перебор массива с помощью forEach**
  let mass = [1, 2, 3, 4, 5]
  mass.forEach(function (item, i, sss) {
    console.log(i + ': ' + "(массив " + sss + ' данных)')
  })

  метод forEach() в методе вызывается callback функция, которая принимает 3 аргумента(не обязательно все применять)
  1) аргумент это то, что находиться в массиве (item)
  2) это (i) индекс массива
  3) это наш массив называем его как хотим

  **Перебор массива с помощью for of и for in**
  let mass = [4, 9, 3, 6, 5]

  for (let key in mass) {
    console.log(key)
  } - отдаст нам номер массива

  for (let key of mass) {
    console.log(key)
  } - отдаст нам то что находиться в массиве 

  **Метод split превращение строки в массив**
  let prom = prompt('', ''),
    mass = [];
    mass=prom.split(',') - превратит строку в массив
  console.log(mass)

  **Метод join превращение массива в строку**
  let mass = ['привет', 'всем'],
    i = mass.join(", ")
      console.log(i)

  **Метод sort сортировка по алфавиту**
  let mass = ['с привет', 'б всем', 'а всем'],
    i = mass.sort()
  console.log(i)
    выведет
  [ 'а всем', 'б всем', 'с привет' ]

  этот метод не очень правильно работает с числами 
  let mass = [1, 15, 4],
    i = mass.sort()
  console.log(i)
  [1, 15, 4]

  **для того чтобы все нормально отображалось используют**
  let mass = [1, 15, 4],
    i = mass.sort(compareNum)

  function compareNum(a,b) {
    return a - b;
  }

  console.log(i)
  [ 1, 4, 15 ]

  ## Разница между массивами и объектами

  const arr = [11, 22, 33]
  console.log(arr[1]) получим 22
  Для того чтобы получить массив нужно обратиться к его индексу который находиться по порядку и если будут добавляться элементы порядок будет меняться

  const arr = [22, 33, 44, 55]
  arr[10] = 374;

  console.log(arr) - выведет [ 22, 33, 44, 55, <6 empty items>, 374 ] то есть 6 пустых строчек, что нарушает порядок массива, так не должно быть.

  **объекты**

  const obj = {a: 11, b: 22, c: 33}
  Чтобы получить элемент нужно обратиться к имени и здесь нет зависимости от порядка

  const myObj = {
    Anna: 500,          можно записывать как в кавычках так и без них
    'Alice': 800
  }

  **добавление на лету в объект**

  let mainObj = {
    mainName: 'Anton',
    mainAge: 38,
    mainSex: 'mane',
  };

  mainObj.b = '123344';

  console.log(mainObj.b); - выведет 123344
  console.log(mainObj['b']); - выведет 123344

  **более приоритетная запись**

  let mainObj = {
    mainName: 'Anton',
    mainAge: '38',
    mainSex: 'mane',
  };
  const b = 'b'; **так более лучше писать**
  mainObj['b'] = '123344';

  console.log(mainObj.b);
  console.log(mainObj['b']);

  ## Объектно ориентированное программирование

  ООП (объектно-ориентированное программирование) - это методология программирования, которая организует программу вокруг объектов, которые объединяют данные и функциональность. В ООП объекты представляют сущности реального мира или абстрактные концепции, и взаимодействие между ними осуществляется через обмен сообщениями. Каждый объект имеет своё состояние (данные) и поведение (методы), и он может взаимодействовать с другими объектами, изменяя своё состояние или вызывая их методы.

  Принципы ООП включают в себя инкапсуляцию, наследование и полиморфизм. Инкапсуляция позволяет объединить данные и методы, работающие с ними, в единую сущность, скрывая детали реализации и обеспечивая контролируемый доступ к ним. Наследование позволяет создавать новые классы на основе уже существующих, наследуя их свойства и методы, что способствует повторному использованию кода и созданию иерархий классов. Полиморфизм позволяет использовать один интерфейс для работы с различными типами объектов, что облегчает создание более гибких и расширяемых программ.

  ООП способствует упрощению разработки программ, улучшению их структуры, повышению повторного использования кода, увеличению надежности и облегчению сопровождения. Оно широко применяется во многих языках программирования, таких как Java, C++, Python, C# и других.

  let soldier = {
    healht: 200,
    armor: 400
  }

  let john = {
    healht: 100
  }
  **с помощью метода __proto__ мы присвоили john прототипы солдата**
  john.__proto__ = soldier;
  console.log(john)
  console.log(john.armor)

  **вывод в консоле**
  { healht: 100 }
  400

  ## Получение элементов со страницы

  DOM - document object model (объектная модель документа)
  **получение элемента по id**
  <div class='box' id='box'></div>
  let box = document.getElementById('box')- получаем один уникальный элемент id

  **получение элемента через теги**
  <button>1</button>
  <button>2</button>
  <button>3</button>
  <button>4</button>
  <button>5</button>
  let btn = document.getElementsByTagName('button') - получаем коллекцию псевдомассивов(псевдомассив лишен св-в массива, нельзя запушить и т.д.), запись пишем как Elements на конце s
  если вывести в console.log(btn[0]); то получим <button>1</button>

  **получение элементов по классу**
  <div class="circle"></div>
  <div class="circle"></div>
  <div class="circle"></div>
  let circle = document.getElementsByClassName('circle')
  console.log(circle[2]) <div class="circle"></div>

  **получение элементов через querySelectorAll**
  <div class="heart"></div>
  <div class="heart"></div>
  <div class="heart"></div>
  <div class="heart"></div>
  let heart = document.querySelectorAll('.heart')
  console.log(heart[2]) <div class="heart"></div> 

  **у этого метода есть 2 преимущества**
  <div class="wrapper">
    <div class="heart"></div>
    <div class="heart"></div>
  </div>

    1) document.querySelectorAll('.wrapper .heart')
    2) можно пробежаться циклом с помощью forEach

  **получение только одного элемента 1-ого на странице**
  <div class="heart"></div>
  let heart = document.querySelector('.heart')
  console.log(heart) <div class="heart"></div> - получит только первый элемент

  ## Действия с элементами на странице
  **присваивание стилей**
  <div class='box' id='box'></div>
  let box = document.getElementById('box')
      box.style.backgroundColor = 'blue' - присваиваем через style цвет нашему элементу

  **присваивание стилей их коллекции только одному элементу**
  <button>1</button>
  <button>2</button>
  <button>3</button>
  <button>4</button>
  <button>5</button>
  let btn = document.getElementsByTagName('button')
      btn[1].style.borderRadius = '100%'

  **получене коллекции и перебор ее циклом**
  <div class="heart"></div>
  <div class="heart"></div>
  <div class="heart"></div>
  let heart = document.querySelectorAll('.heart') - получаем элемент

  for (let i = 0; i < heart.length; i++ ){ - перебираем циклом наш элемент heart
    heart[i].style.backgroundColor = 'blue'; - получаем через индекс каждый наш элемент и красим его в синий цвет
  }

  **получене коллекции и перебор с помощью forEach**
  <div class="heart"></div>
  <div class="heart"></div>
  <div class="heart"></div>
  let heart = document.querySelectorAll('.heart') - получаем элемент

  heart.forEach((item, index, array) => {
    item.style.backgroundColor = 'blue';
  })

  --метод forEach() это функция callback которая принимает три аргумента 1) значение 2) индекс 3) наш массив или коллекцию название будут произвольные--

  **создание элементов на лету с помощью createElement**
  let div = document.createElement('div'),
      text = document.createTextNode('тут был я');

  console.log(div, text)  --- выведет <div></div> 'тут был я'

  ----------**вывод элемента на страницу в конец родителя**

  document.body.appendChild(div) - добавит div в конце body

  ----------**вывод элемента на страницу перед элементом**
  document.body.insertBefore(div, circle[0]) - добавит div перед первым элементом circle (сработает только если есть родительский элемент)

  ----------**удаление элемента со страницы**
  document.body.removeChild(div, circle[1]) - удалит 2-й элемент circle со страницы

  ----------**заменить один элемент на второй**
  document.body.replaceChild(btn[1], circle[1]) - удалит circle[1] и вместо него подставит btn[1]

  **вставить текст или структуру на страницу**

  div.innerHTML = 'Hello World!'
  div.innerHTML = '<h1>Hello World!</h1>'


  **вставить только текст на страницу**

  div.textContent = 'Hello World!'

  **добавление и удаление класса**

  div.classList.add('black') (сработает только если есть родительский элемент)

  ## События и их обработчики

  <button>1</button>
  <button>2</button>
  <button>3</button>
  <button>4</button>
  <button>5</button>
  let btn = document.getElementsByTagName('button')

  **onClick**
  btn[0].onClick = function () {
    alert('Вы нажали первую кнопку!');
  }
  -- если за этим событием прописать еще одно событие то оно перезатрет первое например:
  btn[0].onClick = function () {
    alert('Вы нажали первую кнопку!');
  }

  btn[0].onClick = function () {
    alert('Вы нажали снова первую кнопку!');
  }

  **addEventListener**
  то в alert выведется второе событие, для того чтобы этого избежать используют: 

  btn[0].addEventListener('click', function(){
    alert('Вы нажали первую кнопку!');
    alert('Вы нажали снова первую кнопку!');
  })

  либо:

  btn[0].addEventListener('click', function(){
    alert('Вы нажали первую кнопку!');
  })

  btn[0].addEventListener('click', function(){
    alert('Вы нажали снова первую кнопку!');
  })

  наведение мыши: 

  btn[0].addEventListener('mouseenter', function(){
    alert('Вы наведи на первую кнопку!');
  })

  **объект event**
  если нам нужно получить какието данные о том элементе с которым мы взаимодействуем (например мы хотим узнать что за событие произошло или координаты элемента), для этого используется объект event

  btn[0].addEventListener('click', function(event) {
    console.log('Произошло событие: ' + event.type + ' на элементе ' + event.target)
  })

  где type - это событие
      target - на каком элементе

  чтобы удалить какойто элемент с помощью event 

  btn[0].addEventListener('click', function(event) {
    let delete = event.target;
    delete.style.display = 'none'
  })

  **всплытие собый**
  всплытие собития это когда обработчик сработает вначале на самый вложенный элемент и потом выше и выше например
  <div class='wrap'>
    <button>1</button>
    <button>2</button>
    <button>3</button>
    <button>4</button>
    <button>5</button>
  </div>

  <a href='https://www.youtube.com'> Переход на сайт Ютуб </a>

  let btn = document.getElementsByTagName('button'),
      wrapp = document.querySelector('.wrap'),
      link = document.querySelector('a');

  btn[0].addEventListener('click', function(event) {
    console.log('Произошло событие: ' + event.type + ' на элементе ' + event.target)
  })

  wrap.addEventListener('click', function(event) {
    console.log('Произошло событие: ' + event.type + ' на элементе ' + event.target)
  })

  мы получим вначале значение от btn а затем от wrap.

  ----------**отмена всплытия события**

  link.addEventListener('click', function(event){
    event.preventDefault(); - отменит стандартное поведение
    console.log('Произошло событие: ' + event.type + ' на элементе ' + event.target)
  })

  ----------**повесим обработчик события на несколько элементов**

  btn.forEach(function(item){
    item.addEventListener('mouseleave', function(){
      console.log('вышли')
    })
  })

  ## Скрипты и время их выполнения setTimeout

  let timerId = setTimeout(sayHello, 3000); - в переменной timerId через метод setTimeout первым аргументом вызовем функцию с задержкой в 3000милисекунды

  clearTimeout(temerId); - метод который отменит действие setTimeout

  function sayHello() {
    alert('Hello World');
  }

  **Скрипт setInterval**

  let timerId = setInterval(sayHello, 3000); будет запускать код через каждые 3000 милисекунды

  clearTimeout(temerId); - метод который отменит действие setTimeout

  **Рекурсивный вызов setTimeout**

  let timerId = setTimeout(function log(){
    console.log('hello');
    setTimeout(log, 2000);
  }) - это когда функция setTimeout вызывает сама себя

  **Делегирование события**

  Делегирование события (event delegation) - это паттерн в программировании, который позволяет обрабатывать события на родительском элементе вместо непосредственно на дочерних элементах. При делегировании событий обработчик события привязывается к родительскому элементу, и когда событие происходит на одном из дочерних элементов, оно всплывает вверх по иерархии элементов до тех пор, пока не будет достигнут родительский элемент, где на него назначен обработчик.

  Преимущества делегирования событий:

      Эффективность: Вместо привязки обработчика к каждому дочернему элементу мы можем привязать его только к родительскому элементу, что может быть особенно полезно, если у нас есть большое количество дочерних элементов или они динамически создаются.

      Обработка динамически добавленных элементов: Если у нас есть динамически создаваемые элементы, делегирование событий позволяет обрабатывать события для этих элементов, даже если они появляются на странице после привязки обработчиков.

  **Пример-1**
  btnWrapper.addEventListener('click', function (event) {
    if (event.target && event.target.tagName == 'BUTTON' && event.target == button[2]) {
      console.log('ok');
    } else {
      console.log('no');
    }
  }); // проверка если есть event и если tagName == 'BUTTON' и если это 2я кнопка

  **Пример-2**
  btnWrapper.addEventListener('click', function (event) {
    if (event.target && event.target.classList.contains('first')) {
      console.log('ok');
    } else {
      console.log('no');
    }
  }); // проверка если есть event и c помощью contains проверяем есть ли class:'first'

  **Пример-3**
  btnWrapper.addEventListener('click', function (event) {
    if (event.target && event.target.matches('button.first')) {
      console.log('ok');
    } else {
      console.log('no');
    }
  }); // проверка если есть event и c помощью matches(совпадение) проверяем есть ли определенная кнопка и определенный класс 'button.first'

  ## Параметры документа, окна и работа с ними

----DOM - означает "Document Object Model" (Модель объектов документа). Он представляет структуру и содержимое веб-страницы в виде объектов, которые можно манипулировать с помощью языков программирования, таких как JavaScript.

----В контексте веб-разработки, объект "window" является глобальным объектом, предоставляемым браузером, и представляет окно браузера или вкладку, в которой открыта веб-страница. Он предоставляет множество свойств и методов для управления окном и взаимодействия с пользователем.

Объект "window" также является глобальным контекстом выполнения для JavaScript, что означает, что глобальные переменные и функции доступны как свойства и методы этого объекта. Например, глобальная функция setTimeout() доступна как window.setTimeout().

<!--стили-->

  <div class="main-box">
    Lorem 100
  </div>

  <button class="main-button">
    Нажми
  </button>

  .main-box{
    width: 300px;
    height: 350px;
    padding: 10px;
    border: 5px solid red;
    margin: 20px 0;
    overflow-x: scroll;
    overflow-y: scroll;
  }

  .main-button{
    background: #FFF350;
  }

**размеры без учета линий скрола и border**
let mainBox = document.querySelector('.main-box'),
  width = mainBox.clientWidth,
  height = mainBox.clientHeight;

  console.log(' ширина нашего объекта = ' +  width + ',','высота нашего объекта = ' + height)

**размеры c учетом линий скрола и border**
  let mainBox = document.querySelector('.main-box'),
  width = mainBox.offsetWidth,
  height = mainBox.offsetHeight;

  console.log(' ширина нашего объекта = ' +  width + ',','высота нашего объекта = ' + height)

**размеры c учетом скрола на всю его длинну**
  let mainBox = document.querySelector('.main-box'),
  width = mainBox.scrollWidth,
  height = mainBox.scrollHeight;

  console.log(' ширина нашего объекта = ' +  width + ',','высота нашего объекта = ' + height)

**по клику добавление высоты на весь скролл**
  mainButton.addEventListener('click', function () {
    mainBox.style.height = height + 'px'
  })

**по клику прокрутит наш контент вверх**
  mainButton.addEventListener('click', function () {
    mainBox.scrollTop = 0;
  })

**координаты элемента**
console.log(mainBox.getBoundingClientRect());

---чтобы получить одну координату
console.log(mainBox.getBoundingClientRect().left);








  ## Работа в console

  - Переход в console
    - перейти в корень **c:\**
    - зайти в папку windows с:\>**cd c:\windows если** нужно перейти в **program files** это название состоит из двух слов поэтому берем эту команду в двойные кавычки  с:\windows>**cd “c:\program files”**
    - чтобы зайдя в каталог **c**  или **d** не набирать все руками можно воспользоваться **tab** он работает как переключатель
    - если нужно найти каталог по букве делаем так c:\>**cd c:\P + tab** после этого будут выведены только названия с этой буквы
    
    - чтобы управлять командами которые были введены раннее можно использовать **стрелку вверх или вниз**
    - команды выводятся сверху вниз но если нужно **вывести снизу вверх** зажимаем клавишу **shift+tab**
    - справочник команды **cd /?** набираем имя команды **cd** и комбинацию **/?**
    - 
    
    - чтобы перейти в подкаталоги  c:\>**cd “c:\Program Files (x86)\Internet Explorer”**
    - чтобы перейти назад и c:\>cd “c:\Program Files (x86)\Internet Explore набираем **cd..**
    - чтобы перейти на два каталога ниже c:\Program Files (x86)\Internet Explorer набираем **..\..** мы перейдем **в c:\>**
    - чтобы очистить экран командной строки набираем **cls**
    
    - перейти в папку **Toxa** пишем **cd Toxa** - на английском
    - как перейти на диск d нужно использовать следующую комбинацию C:\Users\Toxa>**cd /d d:\** чтобы перейти на **с** набираем **cd/d c:\**                         **или c: и d:**

  - Работа с console
    - вызов console в visual code : **ctrl + `**
    - поиск : **ctrl + f**
    - переход по ссылке в visual code : **ctrl + нажать левой клавишей мыши**
    - проверить есть ли node.js команда **node -v**
    - пакетный менеджер node.npm команда **npm -v**
    - установка глобально **npm install -g create-react-app**
    - также можно установить jarn вместо npm **npm install -g yarn**
    - проверить наличие папки команда **dir**
    - создаем приложение react  **npx create-react-app example** в конце название папки
    - в браузер chrome нужно зайти в дополнительные инструменты, далее расширения, далее открыть магазин chrome  и установить **React Developer Tools**
    - запустить App.js с помощью **npm run star**t получили ошибку enoent: **no such file or direcory** так как мы не находимся в данной папку набираем **cd example после**  этого набираем  **npm run star**t
    - пакет отвечающий за роутинг в системе React **npm i react-router-dom**
    - быстрый поиск в vs code **ctrl + F**
    - установка sass **npm install -g node-sass**

  - Основные команды 

      -1) cd - команда для изменения текущей рабочей директории.
          Примеры:
            cd <путь> - перейти в указанную директорию. Например, cd Documents перейдет в папку "Documents".
            cd .. - перейти на одну директорию выше (родительская директория).
            cd / - перейти в корневую директорию.
            cd ~ - перейти в домашнюю директорию пользователя.

                -Используйте команду cd с относительным путем:
                    Если целевая папка находится в одной директории с текущей, просто укажите ее имя в команде cd. Например, если вы находитесь в директории "Documents" и хотите перейти в папку "Images", выполните cd Images.
                    Если целевая папка находится в поддиректории текущей директории, укажите путь до нее относительно текущей директории. Например, если вы находитесь в директории "Documents" и хотите перейти в папку "Images", находящуюся внутри папки "Photos", выполните cd Photos/Images.

                -Используйте символы . и ..:
                    Символ . представляет текущую директорию. Если целевая папка находится в текущей директории, просто используйте ее имя. Например, cd Images.
                    Символ .. представляет родительскую директорию. Если целевая папка находится в родительской директории текущей директории, используйте cd ../TargetFolder. Например, если вы находитесь в директории "Documents" и хотите перейти в папку "TargetFolder", находящуюся в родительской директории, выполните cd ../TargetFolder.

                Используйте переменную окружения HOME:
                    В большинстве операционных систем можно использовать переменную окружения HOME, чтобы перейти в домашнюю директорию пользователя. Просто выполните cd $HOME или cd ~ для перехода в домашнюю директорию.

      2) ls - команда для просмотра содержимого текущей директории.
          Примеры:
            ls - показать список файлов и папок в текущей директории.
            ls <путь> - показать список файлов и папок в указанной директории.

      3) pwd - команда для вывода полного пути текущей директории.

      4) mkdir - команда для создания новой директории.
          Пример: mkdir NewFolder - создаст новую папку с именем "NewFolder".

      5) rmdir - команда для удаления пустой директории.
          Пример: rmdir FolderToDelete - удалит папку "FolderToDelete", если она пустая.

      6) rm - команда для удаления файлов и папок.
          Примеры:
              rm file.txt - удалит файл "file.txt".
              rm -r FolderToDelete - удалит папку "FolderToDelete" и все ее содержимое рекурсивно.

      7) mv - команда для перемещения или переименования файлов и папок.
          Примеры:
              mv file.txt destination/ - переместит файл "file.txt" в папку "destination".
              mv file.txt newname.txt - переименует файл "file.txt" в "newname.txt".

      8) cp - команда для копирования файлов и папок.
          Примеры:
              cp file.txt destination/ - скопирует файл "file.txt" в папку "destination".
              cp -r FolderToCopy NewFolder/ - скопирует папку "FolderToCopy" и все ее содержимое в папку "NewFolder" рекурсивно.

      9) clear - команда для очистки экрана консоли.

    10) exit - команда для выхода из консоли или завершения работы командной строки.

    11) cd /d - команда для перехода на другой диск (доступно только в Windows).

    12) Пример: cd /d D: - перейдет на диск "







# GSAP

**Оглавление GSAP**

1. [Знакомство с библиотекой](#Знакомство-с-библиотекой)
2. [Таймлайн](#Таймлайн)
3. [Аккордион gsap](#Аккордион-gsap)
4. [Смена секций по скроллу](#Смена-секций-по-скроллу)

## Знакомство с библиотекой

<!-- у этой бибилиотеки 3 основные свойства -->
1) метод to (из начального положения поменяет на то, что мы задали)
2) метод from (из того что задали вернет в начальное положение)
3) метод fromTo (здесь мы задаем и начальное положение и конечное)

<!-- интересная проверка -->

const block = document.querySelector('.block');
gsap.to(block, {duration: 1, x: 200, opacity: 0});


const btn = document.querySelector('.reverse')

let a = 0;
btn.onclic = function(){
  if(a == 0){
    <!-- выполним услови -->

    a = 1;
  }else{
    <!-- выполним другое условие -->
    a = 0;
  }
}

## Таймлайн
<!-- таймлайны служат для взаимодействия элементов на странице, друг с другом -->

let tl = gsap.timeline(); -- объявили сам таймлайн
let btn = document.querySelector('.reverse')

tl.from('.site', {opacity: 0, duration: 0.5})
  .from('.header', {opacity: 0, duration: 0.5})
  .from('.header-title', {opacity: 0, y: 100, duration: 0.7})
  .from('.header-descr', {opacity: 0, y: 50, duration: 0.7}, '-=0.5') // -=0.5 это задержка времени

btn.onclick = function() {
  tl.reverse(); // метод реверс
}


## Аккордион gsap

<!--! accordion -->

<!-- ? html -->
<ul class="accordion">
  <li class="accordion__item">
    <div class="accordion__top">
      Нажми
    </div>
    <div class="accordion__bottom">
      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Vel sunt corrupti incidunt rerum debitis culpa eos accusantium dignissimos quibusdam corporis sequi numquam quas dolorum sed veritatis, consectetur iste? Quod, nostrum.
    </div>
  </li>
</ul>

<!-- ? css -->
.accordion__item{
  background-color: #131313;
  font-size: 24px;
  color: #fff;
  padding: 40px;
}

.accordion__bottom{
  overflow: hidden;
  height: 0;
}

<!-- ? js -->
const items = document.querySelectorAll('.accordion__item');
let tl = gsap.timeline(); // Перенесено объявление переменной tl

items.forEach((el) => {
  el.addEventListener('click', (e) => {
    let self = e.currentTarget;
    let bottomEl = el.querySelector('.accordion__bottom');

    if (!self.classList.contains('active')) {
      self.classList.add('active');
      tl.to(bottomEl, {
        duration: 0.7,
        height: bottomEl.scrollHeight,
      });
      tl.play();
    } else {
      self.classList.remove('active');
      tl.reverse();
    }
  });
});

<!--! End accordion -->

## Смена секций по скроллу

const tl = gsap.timeline(); <!-- ? Создаем timeleine -->

t1.fromTo('.second', {x: '-100%', y: '+100%'}, {y: 0}) <!-- ? в первых скобках указываем начальное, во вторых конечное значение -->
t1.fromTo('.third', {x: '-100%', y: '-200%'})
t1.fromTo('.second', {x: '-400%', y: '-300%'})

<!-- ! Используем метод ScrollTrigger -->

ScrollTrigger.create({
  animation: t1, <!-- ? задаем ту анимацию которую будем выполнять -->
  trigger: '.site-container', <!-- ? обращаемся к внешней обертке сайта -->
  start: 'top top', <!-- ? параметры где будем начинать анимацию -->
  end: 'bottom', <!-- ? где занокничиться анимация -->
  scrub: true, <!-- ? делаем привязку анимации к скроллу -->
  pin: true <!-- ? закрепляет элемент пока мы скроллим блок -->
})

<!-- ? вариант с концом анимации и подвязкой его под ширину блока -->

const main = document.querySelector('.main');

end: () => main.offsetWidth / 2

## Другой код









чтобы потом использовать это в изображении применяем для контейнера с img

.img-box{
  width: calc(var(--index) * 36); - для ширины
}

.main-title{
  font-size: calc(var(--index) * 6); - для шрифта
  width: min-content;
}


**Js код**
gsap.registerPlugin(ScrollTrigger, ScrollSmoother) - для начала нужно зарегистрировать gsap

<!-- Плавный скролл -->

ScrollSmoother.create({
  wrapper: '.wrapper', - определяем оболочку
  content:  '.content', - здесь будет все плавать 
  effects: true, - управление элементами (запись в блоке data-speed = '.6' ) управление скоростью (data-lag = '.5') будет отставать
})

<!-- откючение на мобильных устройствах скролла -->

if(ScrollTrigger.isTouch !==1) {
  <!--наш код-->
}

<!-- Свойство для того чтобы не пропадала плавность при прокрутке задать всем элеметам которые меняются-->

.wrapper, .content{
  will-change: transform;
}

<!-- Работа с gsap -->

if(ScrollTrigger.isTouch !==1) {

  ScrollSmoother.create({
    wrapper: '.wrapper', 
    content:  '.content',
    effects: true
  })

  <!-- .hero-section - это блок к которому будет применена анимация, {opacity: 1} в первых скобках начальное состояние блока, во вторых те свойства которые будут применены позже -->

  gsap.fromTo('.hero-section', {opacity: 1}, {
    opacity: 0,

    scrollTrigger:{ команда при которой будет срабатывать наш код
      trigger: '.hero-section', - элемент тригерра который будет действовать на анимацию( в то время когда он виден )
      start: 'center', - анимация сработает когда элмент будет в центре
      end: 'bottom', - в какой момент будет конец анимации(когда нижняя граница подходит к верхнему краю окна), можно в числовом эквиваленте (end: '900')


      scrub: true - это свойство которое скажет что при скролле назад нужно вернуть элемент
    }
  })

  <!-- код для всех нескольких элементов который ниже прогоним в массиве -->
  gsap.fromTo('.gallery__left .gallery__item', {x: -500, opacity: 0}, {
    opacity: 1,
    x: 0,
    scrollTrigger:{
      trigger: '.gallery__item',

      scrub: true
    }
  })

  <!-- поскольку элементов у нас несколько будем работать с циклом помещаем код в специальный метод gsap.utils.toArray(...)-->

  let itemsLeft = gsap.utils.toArray(.gallery__left .gallery__item)

  itemsLeft.forEach(item =>{
    gsap.fromTo('item', {x: -500, opacity: 0}, {
      opacity: 1,
      x: 0,
      scrollTrigger:{
        trigger: 'item',
        start: '850',
        end: '-100',

        scrub: true
      }
    })
  })
}

# CSS

**Оглавление css**

1. [Переменные css](#Переменные-css)

:root{
  --index: calc(1vw + 1vh); - определяем индекс для экрана, для того чтобы верстка резинилась.
}

### Переменные css

